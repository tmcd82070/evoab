% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimateL.EoA.R
\name{estimateL.EoA}
\alias{estimateL.EoA}
\title{estimateL.EoA - Estimate single-site EoA and Informed EoA
lambda parameters via JAGS}
\usage{
estimateL.EoA(X, beta.params, Lprior = "uniform", Lprior.mean = NULL,
  Lprior.sd = NULL, LMax = 62, conf.level = 0.9, seeds = NULL,
  niters = 10000, nthins = 10, nburn = 50000, nadapt = 2000,
  nchains = 3)
}
\arguments{
\item{X}{Total number of search targets found at all searched sites during the
entire search season.}

\item{beta.params}{A list containing, at a minimum, components named $alpha and $beta.
These are the all-site alpha and beta parameters for g. In many cases, these parameters
are computed using function \code{\link{getFleetG}}.}

\item{Lprior}{A string naming the prior distribution to use for lambda.
"uniform" uses a uniform prior on [0,\code{LMax}].
"normal" uses a normal(\code{Lprior.mean},\code{Lprior.sd}) prior for lambda.
"gamma" uses a gamma(alpha,beta) prior for lambda, where alpha =
\code{Lprior.mean^2}/\code{Lprior.sd^2} and beta = \code{Lprior.mean}/
\code{Lprior.sd^2} (i.e., alpha and beta are the method of moment estimates
for the shape and rate parameter of a gamma distribution; JAGS uses the shape-rate
parameterization of the gamma).}

\item{Lprior.mean}{Mean of lambda prior when Lprior == "normal" or "gamma".}

\item{Lprior.sd}{Standard deviation of normal when Lprior == "normal" or "gamma".}

\item{LMax}{Maximum lambda when Lprior = "uniform".  CAREFUL: set this to a number
that is well beyond the upper limit of the confidence interval on lambda.  i.e.,
you may need to run this a couple times to make this big enough.}

\item{conf.level}{Confidence level for the confidence intervals on lambda.}

\item{seeds}{A vector of length \code{nchains} containing random number
seeds for the MCMC sampler.  If NULL, \code{nchains} random numbers are
generated from R's base random number generator which is controled outside
this routine using \code{set.seed}.  Regardless of the random number
sequence set outside this routine, specifying \code{seeds} will set
the MCMC seeds in JAGS so that exact chains can be reproduced. Note
that \code{set.seed} has no effect on the random number sequences used
in JAGS.  The seeds, whether chosen by this routine or specified, are
stored in the output object.}

\item{niters}{The number of sampling steps to take during MCMC sampling.}

\item{nthins}{The amount of MCMC chain thinning to do.  Every (\code{nthins})-th
sampling iteration (of which there are \code{niters}) is saved, while the
rest are discarded. In the end, a total of \code{niters/nthins} samples from
the posterior are available to the user.}

\item{nadapt}{The number of adapting iterations to perform before
burn-in.  During adaptin, JAGS is trying to optimize it's proposal distribution
and stepsize to increase convergence speed.}

\item{nchains}{The number of MCMC sampling chains. Specify 2 or more to
check convergence.}

\item{nburns}{The number of burn-in steps to take during MCMC sampling.}
}
\value{
List containing two components:
\itemize{
  \item  \code{$lamda.ests} is a data
frame containing the lambda estiamtes (point estimate and confidence interval).
  \item \code{$out} is the full MCMC chain object.  Use this to check convergence, etc.
}
}
\description{
This routine computes lambda, the mean number of search targets per season,
from information about the number of found targets and the g-value (=probatility of
discovery).  The method is Bayesian and allows either an uniform prior for lambda
or an informed prior.
Estimation is performed using JAGS.
}
\examples{

syr <- data.frame(species=c("LBBA","LBBA","LBBA"),
   facility=c("f1","f2","f2"),
   gFac.a = c( 69.9299, 63.5035,  84.6997),
   gFac.b = c(  736.4795,  318.3179, 759.9333 ),
   year = c(2015,2015,2016))
g <- getFleetG(syr, "LBBA"))

eoa <- estimateL.EoA( 1, g, LMax=500 )  # Un-informed EoA

ieoa <- estimateL.EoA( 1, g, Lprior="normal", Lprior.mean=20, Lprior.sd=4) # Informed EoA


# To check convergence, run traceplot and Gelman stats
plot(ieoa$out) # tracePlot
gelman.diag(ieoa$out) # gelmanStats
gelman.plot(ieoa$out) # gelmanPlot
}
